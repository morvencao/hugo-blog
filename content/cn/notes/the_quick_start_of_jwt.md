---
title: "JSON WEB令牌"
date: 2017-04-20
type: "notes"
draft: false
---

近几年，前后端分离大行其道。在典型的前后端分离的应用架构中，后端主要作为Model层，为前端提供数据访问API。前后端之间的通信需要在不可信（Zero Trust）的异构网络之间进行，为了保证数据安全可靠地在客户端与服务端之间传输，实现服务端的客户端认证就显得非常重要。而HTTP协议本身是无状态的，实现服务端的客户端认证的基础是记录客户端和服务端的对话状态。


我们最熟悉的服务端认证客户端的方式就是基于Session/Cookie的状态记录方式，服务端在第一次请求时声生成对应的Session发送给客户端保存在Cookie中，同时Session信息还会保存在服务器端，然后客户端之后对于服务器端的每次请求都需要带上Cookie，服务器端取出相应Session并与保存的Session信息进行对比，以实现身份的认证。

![](https://i.loli.net/2019/07/13/5d29cd435e80182826.jpg)


这种模式最大的问题是，没有分布式架构，无法支持横向扩展。如果使用一个服务器，该模式完全没有问题。但是，如果它是服务器群集或面向服务的跨域体系结构的话，则需要一个统一的session数据库库来保存会话数据实现共享，这样负载均衡下的每个服务器才可以正确的验证用户身份。

举例来说，某企业同时有两个不同的网站A和网站B提供服务，如何做到用户只需要登录其中一个网站，然后它就会自动登录到另一个网站？

一种解决方案是使用听过持久化Session的基础设施（如Redis），写入Session数据到持久层。收到新的客户端请求后，服务端从从持久层查找对应的Session信息。这种方案的优点在于架构清晰，而缺点是架构修改比较费劲，整个服务的验证逻辑层都需要重写，工作量相对较大。而且由于依赖于持久层的数据库或者问题系统，会有单点风险，如果持久层失败，整个认证体系都会挂掉。

![](https://i.loli.net/2019/07/13/5d29c64a39f9615138.jpg)


儿JWT另辟蹊径，基于Token（令牌）认证客户端，也就是说只需要在每次客户端的请求的HTTP头部附上 对应的Token，由服务器端去检查Token的签名来确保Token没有被篡改，这样通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器端认证。


### 什么是JWT(JSON Web Token)

根据[官方](https://jwt.io/introduction/)的定义，JWT是一套开放的标准（[RFC 7519](https://tools.ietf.org/html/rfc7519)），它定义了一套简洁（compact）且安全（URL-safe）的方案，可以在客户端和服务器之间传输JSON格式的Token信息。

### JWT工作原理

![]()

JWT服务端认证的基本原理是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。

```
{
    "username": "morvencao",
    "role": "Admin",
    "expire": "2017-02-08 12:45:43"
}
```

之后，当客户端与服务器端通信时，客户端需要在请求中发回这个JSON对象。服务器仅依赖于这个JSON对象的内容来认证客户端。为了防止中间人（man-in-middle）篡改数据，服务器将在生成JSON对象时添加签名。但服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。


#### JWT的数据结构

一个典型的JWT的数据结构看起来如下图所示：

![]()

JWT对象为一个很长的字符串，字符之间通过"."分隔符分为三个子串，各字串之间也没有换行符。每一个子串表示了一个功能块，总共有以下三个部分：

1. JWT头

JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示：

```
{
    "alg": "HS256",
    "typ": "JWT"
}
```

在上面的代码片段中，`alg`属性表示签名使用的算法，默认为`HMAC SHA256`（HS256）；`typ`属性表示令牌的类型，JWT令牌统一写为`JWT`；最后，使用`Base64URL`算法将上述JSON对象转换为字符串保存。

2. 有效载荷

有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。JWT指定七个默认字段供选择：

```
iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID用于标识该JWT
```

除以上默认字段外，我们还可以自定义私有字段，如下例所示：

```
{
    "sub": "xxxxxxxxx",
    "username": "morvencao",
    "role": "Admin",
    "expire": "2017-02-08 12:45:43"
}
```

> Note: 默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。

JSON对象也使用`Base64URL`算法转换为字符串保存。

3. 签名哈希

签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。

首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为`HMAC SHA256`）根据以下公式生成签名：

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

在计算出签名哈希后，`JWT头`+`有效载荷`+`签名哈希`三个部分组合成一个字符串，每个部分用"."分隔，就构成整个JWT对象。


### 优点

- 体积小：一串字符串，传输速度快
- 传输方式多样：可以通过 HTTP 头部（推荐）/URL/POST 参数等方式传输
- 严谨的结构化：它自身（在payload中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且payload支持应用定制
- 支持跨域验证：多应用于单点登录

其实，除了以上很容易看得见的优点之外，相对于传统的服务端认证，JWT还有以下优点：

1. 充分依赖无状态API，契合RESTful设计原则

JWT的设计契合无状态原则：用户登录之后，服务器会返回一串token并保存在本地，在这之后的服务器访问都要带上这串token，来获得访问相关路由、服务及资源的权限。比如单点登录就比较多地使用了JWT，因为它的体积小，并且经过简单处理（使用HTTP头带上Bearer属性 + token）就可以支持跨域操作。

2. 易于实现 CDN，将静态资源分布式管理

在传统的session验证中，服务端必须保存session ID，用于与用户传过来的cookie验证。而一开始session只会保存在一台服务器上，所以只能由一台server应答，就算其他服务器有空闲也无法应答，无法充分利用到分布式服务器的优点。JWT依赖的是在客户端本地保存验证信息，不需要利用服务器保存的信息来验证，所以任意一台服务器都可以应答，服务器的资源也能被较好地利用。

3. 认证解耦，随处生成

无需使用特定的身份验证方案，只要拥有生成token所需的认证信息，在何处都可以调用相应接口生成token，无需繁琐的耦合的认证操作，可谓是一次生成，永久使用。
